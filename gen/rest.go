package gen

import (
	"github.com/lunelabs/go-gen-rest/model"
	"html/template"
	"os"
	"strings"
)

type Rest struct {
	basePackage string
	resources   []model.Resource
}

func NewRest(basePackage string, resources []model.Resource) *Rest {
	return &Rest{
		basePackage: basePackage,
		resources:   resources,
	}
}

func (r *Rest) Generate() {
	for _, resource := range r.resources {
		r.GenerateCreateRequest(resource)
		r.GenerateFilter(resource)
		r.GenerateResponse(resource)
		r.GenerateBaseController(resource, r.basePackage)
		r.GenerateController(resource, r.basePackage)
		r.GenerateResource(resource, r.basePackage)
	}
}

func (r *Rest) GenerateCreateRequest(resource model.Resource) {
	funcMap := template.FuncMap{
		"fieldCase": fieldCase,
		"titleCase": strings.Title,
	}

	f, err := os.Create("./../../request/create_" + resource.Name + ".gen.go")

	if err != nil {
		panic(err)
	}

	defer f.Close()

	var requestTemplate = template.Must(template.New("").Funcs(funcMap).Parse(`// Code generated by go generate; DO NOT EDIT.{{ $tick := "` + "`" + `" }}

package request

type Create{{ .Name | fieldCase }} struct { {{ range $key, $value := .Fields }}
	{{if not $value.IdField}}{{ $value.Name | fieldCase }} {{ $value.Type }} {{ $tick }}json:"{{ $value.Name }}"{{if $value.FilterValidator }} validate:"{{ $value.FilterValidator }} "{{end}}{{ $tick }}{{ end }}{{ end }}
}
`))

	requestTemplate.Execute(f, resource)
}

func (r *Rest) GenerateFilter(resource model.Resource) {
	funcMap := template.FuncMap{
		"fieldCase": fieldCase,
		"titleCase": strings.Title,
	}

	f, err := os.Create("./../../request/" + resource.Name + "_filter.gen.go")

	if err != nil {
		panic(err)
	}

	defer f.Close()

	var requestTemplate = template.Must(template.New("").Funcs(funcMap).Parse(`// Code generated by go generate; DO NOT EDIT.{{ $tick := "` + "`" + `" }}

package request

type {{ .Name | fieldCase }}Filter struct { {{ range $key, $value := .Fields }}
	{{if $value.Filter}}{{ $value.Name | fieldCase }} {{ $value.Type }} {{ $tick }}json:"{{ $value.Name }}"{{if $value.FilterValidator }} validate:"{{ $value.FilterValidator }}"{{end}}{{ $tick }}{{ end }}{{ end }}
}
`))

	requestTemplate.Execute(f, resource)
}

func (r *Rest) GenerateResponse(resource model.Resource) {
	funcMap := template.FuncMap{
		"fieldCase": fieldCase,
		"titleCase": strings.Title,
	}

	f, err := os.Create("./../../response/" + resource.Name + ".gen.go")

	if err != nil {
		panic(err)
	}

	defer f.Close()

	var requestTemplate = template.Must(template.New("").Funcs(funcMap).Parse(`// Code generated by go generate; DO NOT EDIT.{{ $tick := "` + "`" + `" }}

package response

type {{ .Name | fieldCase }} struct { {{ range $key, $value := .Fields }}
	{{ $value.Name | fieldCase }} {{ $value.Type }} {{ $tick }}json:"{{ $value.Name }}"{{ $tick }}{{ end }}
}
`))

	requestTemplate.Execute(f, resource)
}

func (r *Rest) GenerateBaseController(resource model.Resource, basePackage string) {
	funcMap := template.FuncMap{
		"fieldCase": fieldCase,
		"titleCase": strings.Title,
		"basePackage": func() string {
			return basePackage
		},
	}

	var baseControllerTemplate = template.Must(template.New("").Funcs(funcMap).Parse(`// Code generated by go generate; DO NOT EDIT.{{ $tick := "` + "`" + `" }}

package controller

import (
	"net/http"
	"{{ basePackage }}/resource"
	"{{ basePackage }}/request"
	"github.com/lunelabs/go-gen-rest/contrl"
	"github.com/gorilla/mux"
)

type Base{{ .Name | fieldCase }}Controller struct {
	resource *resource.{{ .Name | fieldCase }}Resource
	contrl.BaseController
}

func (c *Base{{ .Name | fieldCase }}Controller) Create(w http.ResponseWriter, r *http.Request) {
	var req request.Create{{ .Name | fieldCase }}

	if err := c.GetRequestObject(r, &req); err != nil {
		c.WriteErrorResponse(
			w,
			err.ErrorMessage,
			err.ErrorCode,
			err.StatusCode,
		)

		return
	}

	result, err := c.resource.Create(req)

	if err != nil {
		c.WriteErrorResponse(
			w,
			err.ErrorMessage,
			err.ErrorCode,
			err.StatusCode,
		)

		return
	}

	c.WriteJsonResponse(w, result)
}

func (c *Base{{ .Name | fieldCase }}Controller) Delete(w http.ResponseWriter, r *http.Request) {
	id := mux.Vars(r)["hash"]

	if err := c.resource.Delete(id); err != nil {
		c.WriteErrorResponse(
			w,
			err.ErrorMessage,
			err.ErrorCode,
			err.StatusCode,
		)

		return
	}
}

func (c *Base{{ .Name | fieldCase }}Controller) Get(w http.ResponseWriter, r *http.Request) {
	id := mux.Vars(r)["hash"]

	result, err := c.resource.Get(id)

	if err != nil {
		c.WriteErrorResponse(
			w,
			err.ErrorMessage,
			err.ErrorCode,
			err.StatusCode,
		)

		return
	}

	c.WriteJsonResponse(w, result)
}

func (c *Base{{ .Name | fieldCase }}Controller) GetAll(w http.ResponseWriter, r *http.Request) {
	var filter request.{{ .Name | fieldCase }}Filter

	if err := c.GetRequestFilter(r, &filter); err != nil {
		c.WriteErrorResponse(
			w,
			err.ErrorMessage,
			err.ErrorCode,
			err.StatusCode,
		)

		return
	}

	result, err := c.resource.GetAll(filter)

	if err != nil {
		c.WriteErrorResponse(
			w,
			err.ErrorMessage,
			err.ErrorCode,
			err.StatusCode,
		)

		return
	}

	c.WriteJsonResponse(w, result)
}
`))

	f, err := os.Create("./../../controller/base_" + resource.Name + "_controller.go")

	if err != nil {
		panic(err)
	}

	defer f.Close()

	baseControllerTemplate.Execute(f, resource)
}

func (r *Rest) GenerateController(resource model.Resource, basePackage string) {
	funcMap := template.FuncMap{
		"fieldCase": fieldCase,
		"titleCase": strings.Title,
		"basePackage": func() string {
			return basePackage
		},
	}

	var controllerTemplate = template.Must(template.New("").Funcs(funcMap).Parse(`package controller

import (
	"{{ basePackage }}/resource"
)

type {{ .Name | fieldCase }}Controller struct {
	resource *resource.{{ .Name | fieldCase }}Resource
	Base{{ .Name | fieldCase }}Controller
}

func New{{ .Name | fieldCase }}Controller(resource *resource.{{ .Name | fieldCase }}Resource) *{{ .Name | fieldCase }}Controller {
	return &{{ .Name | fieldCase }}Controller{
		Base{{ .Name | fieldCase }}Controller: Base{{ .Name | fieldCase }}Controller{resource: resource},
	}
}
`))

	if _, err := os.Stat("./../../controller/" + resource.Name + "_controller.go"); os.IsNotExist(err) {
		f, err := os.Create("./../../controller/" + resource.Name + "_controller.go")

		if err != nil {
			panic(err)
		}

		defer f.Close()

		controllerTemplate.Execute(f, resource)
	}
}

func (r *Rest) GenerateResource(resource model.Resource, basePackage string) {
	funcMap := template.FuncMap{
		"fieldCase": fieldCase,
		"titleCase": strings.Title,
		"basePackage": func() string {
			return basePackage
		},
	}

	var requestTemplate = template.Must(template.New("").Funcs(funcMap).Parse(`package resource

import (
	"errors"
	"github.com/lunelabs/go-gen-rest/error"
	"github.com/lunelabs/go-gen-rest/resp"
	"{{ basePackage }}/request"
	"{{ basePackage }}/response"
)

type {{ .Name | fieldCase }}Resource struct {
}

func New{{ .Name | fieldCase }}Resource() *{{ .Name | fieldCase }}Resource {
	return &{{ .Name | fieldCase }}Resource{}
}

func (c *{{ .Name | fieldCase }}Resource) Create(request request.Create{{ .Name | fieldCase }}) (response.{{ .Name | fieldCase }}, *error.Error) {
	return response.{{ .Name | fieldCase }}{}, &error.Error{
		StatusCode: 500,
		ErrorCode:   "not_implemented",
		ErrorMessage: "not implemented",
		Err:        errors.New("not implemented"),
	}
}

func (c *{{ .Name | fieldCase }}Resource) Delete(id interface{}) *error.Error {
	return &error.Error{
		StatusCode: 500,
		ErrorCode:   "not_implemented",
		ErrorMessage: "not implemented",
		Err:        errors.New("not implemented"),
	}
}

func (c *{{ .Name | fieldCase }}Resource) Get(id interface{}) (response.{{ .Name | fieldCase }}, *error.Error) {
	return response.{{ .Name | fieldCase }}{}, &error.Error{
		StatusCode: 500,
		ErrorCode:   "not_implemented",
		ErrorMessage: "not implemented",
		Err:        errors.New("not implemented"),
	}
}

func (c *{{ .Name | fieldCase }}Resource) GetAll(filter request.{{ .Name | fieldCase }}Filter) (resp.Collection, *error.Error) {
	return resp.Collection{}, &error.Error{
		StatusCode: 500,
		ErrorCode:   "not_implemented",
		ErrorMessage: "not implemented",
		Err:        errors.New("not implemented"),
	}
}
`))

	if _, err := os.Stat("./../../resource/" + resource.Name + "_resource.go"); os.IsNotExist(err) {
		f, err := os.Create("./../../resource/" + resource.Name + "_resource.go")

		if err != nil {
			panic(err)
		}

		defer f.Close()

		requestTemplate.Execute(f, resource)
	}
}

func fieldCase(field string) string {
	words := strings.Split(field, "_")
	fixed := ""

	for _, word := range words {
		if word == "ip" {
			fixed = fixed + "IP"

			continue
		}

		fixed = fixed + strings.Title(word)
	}

	return fixed
}
